/*
 * libsensord-share
 *
 * Copyright (c) 2014 Samsung Electronics Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <sensor_loader.h>
#include <libxml/xmlmemory.h>
#include <libxml/parser.h>
#include <sensor_hal.h>
#include <sensor_base.h>
#include <physical_sensor.h>
#include <dlfcn.h>
#include <dirent.h>
#include <sensor_logs.h>
#include <unordered_set>
#include <algorithm>

#ifdef ENABLE_AUTO_ROTATION
#include <auto_rotation_sensor.h>
#endif

using std::vector;
using std::string;

#define DEVICE_PLUGINS_DIR_PATH "/usr/lib/sensor"
#define SENSOR_TYPE_SHIFT 32
#define SENSOR_INDEX_SHIFT 16

sensor_loader::sensor_loader()
{
}

sensor_loader& sensor_loader::get_instance()
{
	static sensor_loader inst;
	return inst;
}

bool sensor_loader::load_devices(const string &path, vector<sensor_device_t> &devices, void* &handle)
{
	int size;
	sensor_device_t *_devices = NULL;

	INFO("load device: [%s]", path.c_str());

	void *_handle = dlopen(path.c_str(), RTLD_NOW);

	if (!_handle) {
		ERR("Failed to dlopen(%s), dlerror : %s", path.c_str(), dlerror());
		return false;
	}

	dlerror();

	create_t create_devices = (create_t) dlsym(_handle, "create");

	if (!create_devices) {
		ERR("Failed to find symbols in %s", path.c_str());
		dlclose(_handle);
		return false;
	}

	size = create_devices(&_devices);

	if (!_devices) {
		ERR("Failed to create devices, path is %s\n", path.c_str());
		dlclose(_handle);
		return false;
	}

	devices.clear();

	for (int i = 0; i < size; ++i)
		devices.push_back(_devices[i]);

	handle = _handle;

	delete _devices;

	return true;
}

physical_sensor* sensor_loader::create_sensor(sensor_handle_t handle, sensor_device *device)
{
	int16_t index;
	physical_sensor *sensor;

	index = (int16_t) (m_sensors.count((sensor_type_t)handle.type));

	sensor = new(std::nothrow) physical_sensor();
	if (!sensor) {
		ERR("Memory allocation failed[%s]", handle.name);
		return NULL;
	}

	sensor->set_id((int64_t)handle.type << SENSOR_TYPE_SHIFT | index << SENSOR_INDEX_SHIFT | handle.id);
	sensor->set_sensor_handle(handle);
	sensor->set_sensor_device(device);

	return sensor;
}

bool sensor_loader::load_physical_sensors(std::vector<sensor_device_t> &devices)
{
	int size;
	sensor_device *device;
	const sensor_handle_t *handles;
	physical_sensor *sensor;

	for (void *device_ptr : devices) {
		device = static_cast<sensor_device *>(device_ptr);

		size = device->get_sensors(&handles);

		for (int i = 0; i < size; ++i) {
			sensor = create_sensor(handles[i], device);
			if (!sensor)
				continue;

			std::shared_ptr<sensor_base> sensor_ptr(sensor);
			m_sensors.insert(std::make_pair((sensor_type_t)(handles[i].type), sensor_ptr));

			INFO("inserted [%s] sensor", sensor->get_name());
		}
	}

	return true;
}

bool sensor_loader::load_sensors(void)
{
	vector<string> device_plugin_paths;
	vector<string> unique_device_plugin_paths;

	get_paths_from_dir(string(DEVICE_PLUGINS_DIR_PATH), device_plugin_paths);

	std::unordered_set<string> s;
	auto unique = [&s](vector<string> &paths, const string &path) {
		if (s.insert(path).second)
			paths.push_back(path);
	};

	for_each(device_plugin_paths.begin(), device_plugin_paths.end(),
		[&](const string &path) {
			unique(unique_device_plugin_paths, path);
		}
	);

	for_each(unique_device_plugin_paths.begin(), unique_device_plugin_paths.end(),
		[&](const string &path) {
			void *handle;
			std::vector<sensor_device_t> devices;

			load_devices(path, devices, handle);
			load_physical_sensors(devices);
		}
	);

	load_virtual_sensors();

	show_sensor_info();
	return true;
}

template <typename _sensor>
void sensor_loader::load_virtual_sensor(const char *name)
{
	sensor_type_t type;
	int16_t index;
	virtual_sensor *instance = NULL;

	try {
		instance = new _sensor;
	} catch (std::exception &e) {
		ERR("Failed to create %s sensor, exception: %s", name, e.what());
		return;
	} catch (int err) {
		ERR("Failed to create %s sensor err: %d, cause: %s", name, err, strerror(err));
		return;
	}

	if (!instance->init()) {
		ERR("Failed to init %s", name);
		delete instance;
		return;
	}

	std::shared_ptr<sensor_base> sensor(instance);

	type = sensor->get_type();
	index = (int16_t)(m_sensors.count(type));

	sensor->set_id((int64_t)type << SENSOR_TYPE_SHIFT | index);

	m_sensors.insert(std::make_pair(type, sensor));
}

void sensor_loader::load_virtual_sensors(void)
{
	load_virtual_sensor<auto_rotation_sensor>("Auto Rotation");
}

void sensor_loader::show_sensor_info(void)
{
	INFO("========== Loaded sensor information ==========\n");

	int index = 0;

	auto it = m_sensors.begin();

	while (it != m_sensors.end()) {
		sensor_base *sensor = it->second.get();

		sensor_info info;
		sensor->get_sensor_info(info);
		INFO("No:%d [%s]\n", ++index, sensor->get_name());
		info.show();
		it++;
	}

	INFO("===============================================\n");
}

bool sensor_loader::get_paths_from_dir(const string &dir_path, vector<string> &plugin_paths)
{
	DIR *dir = NULL;
	struct dirent *dir_entry = NULL;

	dir = opendir(dir_path.c_str());

	if (!dir) {
		ERR("Failed to open dir: %s", dir_path.c_str());
		return false;
	}

	string name;

	while ((dir_entry = readdir(dir))) {
		name = string(dir_entry->d_name);
		plugin_paths.push_back(dir_path + "/" + name);
	}

	closedir(dir);
	return true;
}

sensor_base* sensor_loader::get_sensor(sensor_type_t type)
{
	auto it_plugins = m_sensors.find(type);

	if (it_plugins == m_sensors.end())
		return NULL;

	return it_plugins->second.get();
}

sensor_base* sensor_loader::get_sensor(sensor_id_t id)
{
	vector<sensor_base *> sensors;

	sensor_type_t type = static_cast<sensor_type_t> (id >> SENSOR_TYPE_SHIFT);
	unsigned int index = (id >> SENSOR_INDEX_SHIFT) & 0xFFFF;

	sensors = get_sensors(type);

	if (sensors.size() <= index)
		return NULL;

	return sensors[index];
}

vector<sensor_type_t> sensor_loader::get_sensor_types(void)
{
	vector<sensor_type_t> sensor_types;

	auto it = m_sensors.begin();

	while (it != m_sensors.end()) {
		sensor_types.push_back((sensor_type_t)(it->first));
		it = m_sensors.upper_bound(it->first);
	}

	return sensor_types;
}

vector<sensor_base *> sensor_loader::get_sensors(sensor_type_t type)
{
	vector<sensor_base *> sensor_list;
	std::pair<sensor_map_t::iterator, sensor_map_t::iterator> ret;

	if ((int)(type) == (int)SENSOR_DEVICE_ALL)
		ret = std::make_pair(m_sensors.begin(), m_sensors.end());
	else
		ret = m_sensors.equal_range(type);

	for (auto it = ret.first; it != ret.second; ++it)
		sensor_list.push_back(it->second.get());

	return sensor_list;
}

vector<sensor_base *> sensor_loader::get_virtual_sensors(void)
{
	vector<sensor_base *> virtual_list;
	sensor_base* sensor;

	for (auto sensor_it = m_sensors.begin(); sensor_it != m_sensors.end(); ++sensor_it) {
		sensor = sensor_it->second.get();

		if (sensor && sensor->is_virtual() == true) {
			virtual_list.push_back(sensor);
		}
	}

	return virtual_list;
}
