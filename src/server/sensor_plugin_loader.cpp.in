/*
 * libsensord-share
 *
 * Copyright (c) 2014 Samsung Electronics Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <sensor_plugin_loader.h>
#include <libxml/xmlmemory.h>
#include <libxml/parser.h>
#include <sensor_hal.h>
#include <sensor_base.h>
#include <physical_sensor.h>
#include <dlfcn.h>
#include <dirent.h>
#include <sensor_logs.h>
#include <unordered_set>
#include <algorithm>

#ifdef ENABLE_AUTO_ROTATION
#include <auto_rotation_sensor.h>
#endif
/*
#ifdef ENABLE_TILT
#include <tilt_sensor.h>
#endif
#ifdef ENABLE_GRAVITY
#include <gravity_sensor.h>
#endif
#ifdef ENABLE_SENSOR_FUSION
#include <fusion_sensor.h>
#endif
#ifdef ENABLE_LINEAR_ACCEL
#include <linear_accel_sensor.h>
#endif
#ifdef ENABLE_ORIENTATION
#include <orientation_sensor.h>
#endif
#ifdef ENABLE_GAMING_RV
#include <gaming_rv_sensor.h>
#endif
#ifdef ENABLE_GEOMAGNETIC_RV
#include <geomagnetic_rv_sensor.h>
#endif
#ifdef ENABLE_RV
#include <rv_sensor.h>
#endif
#ifdef ENABLE_GYROSCOPE_UNCAL
#include <gyroscope_uncal_sensor.h>
#endif
*/

using std::unordered_set;
using std::vector;
using std::string;

#define ROOT_ELEMENT "PLUGIN"
#define TEXT_ELEMENT "text"
#define PATH_ATTR "path"
#define HAL_ELEMENT "HAL"
#define SENSOR_ELEMENT "SENSOR"

#define HAL_PLUGINS_DIR_PATH "/usr/lib/sensor"

#define SENSOR_INDEX_SHIFT 16

sensor_plugin_loader::sensor_plugin_loader()
{
}

sensor_plugin_loader& sensor_plugin_loader::get_instance()
{
	static sensor_plugin_loader inst;
	return inst;
}

bool sensor_plugin_loader::load_plugin(const string &path, vector<void*> &sensors, void* &handle)
{
	INFO("load HAL plugin [%s]", path.c_str());

	void *_handle = dlopen(path.c_str(), RTLD_NOW);

	if (!_handle) {
		ERR("Failed to dlopen(%s), dlerror : %s", path.c_str(), dlerror());
		return false;
	}

	dlerror();

	create_t create_plugin = (create_t) dlsym(_handle, "create");

	if (!create_plugin) {
		ERR("Failed to find symbols in %s", path.c_str());
		dlclose(_handle);
		return false;
	}

	sensor_module *plugin = create_plugin();

	if (!plugin) {
		ERR("Failed to create plugin, path is %s\n", path.c_str());
		dlclose(_handle);
		return false;
	}

	sensors.clear();
	sensors.swap(plugin->sensors);

	delete plugin;
	handle = _handle;

	return true;
}

bool sensor_plugin_loader::insert_plugins(std::vector<void *> hals)
{
	unsigned int i;
	sensor_hal *hal;

	for (i = 0; i < hals.size(); ++i) {
		hal = static_cast<sensor_hal *>(hals[i]);

		insert_sensors(hal);
	}

	return true;
}

bool sensor_plugin_loader::insert_sensors(sensor_hal *hal)
{
	unsigned int i;
	vector<sensor_handle_t> sensors;
	physical_sensor *phy_sensor;

	hal->get_sensors(sensors);

	for (i = 0; i < sensors.size(); ++i) {
		int idx;
		idx = m_sensors.count(sensors[i].type);

		phy_sensor = new(std::nothrow) physical_sensor();
		if (!phy_sensor) {
			ERR("Memory allocation failed[%s]", sensors[i].name.c_str());
			continue;
		}

		phy_sensor->set_id(idx << SENSOR_INDEX_SHIFT | sensors[i].type);
		phy_sensor->set_sensor_handle(sensors[i]);
		phy_sensor->set_sensor_hal(hal);

		std::shared_ptr<sensor_base> sensor(phy_sensor);
		m_sensors.insert(std::make_pair(sensors[i].type, sensor));

		INFO("created [%s] sensor", sensor->get_name());
	}

	return true;
}

bool sensor_plugin_loader::load_plugins(void)
{
	vector<string> hal_paths;
	vector<string> unique_hal_paths;

	get_paths_from_dir(string(HAL_PLUGINS_DIR_PATH), hal_paths);

	unordered_set<string> s;
	auto unique = [&s](vector<string> &paths, const string &path) {
		if (s.insert(path).second)
			paths.push_back(path);
	};

	for_each(hal_paths.begin(), hal_paths.end(),
		[&](const string &path) {
			unique(unique_hal_paths, path);
		}
	);

	for_each(unique_hal_paths.begin(), unique_hal_paths.end(),
		[&](const string &path) {
			void *handle;
			std::vector<void *> hals;

			load_plugin(path, hals, handle);
			insert_plugins(hals);
		}
	);

#ifdef ENABLE_AUTO_ROTATION
	auto_rotation_sensor* auto_rot_sensor_ptr = NULL;
	try {
		auto_rot_sensor_ptr = new(std::nothrow) auto_rotation_sensor;
	} catch (int err) {
		ERR("Failed to create auto_rotation_sensor module, err: %d, cause: %s", err, strerror(err));
	}
	if (auto_rot_sensor_ptr != NULL) {
		std::shared_ptr<sensor_base> sensor(auto_rot_sensor_ptr);
		sensor_hal_type type;

		type = static_cast<sensor_hal_type>(sensor->get_type());
		sensor->set_id(type);

		m_sensors.insert(std::make_pair(type, sensor));
	}
#endif

	show_sensor_info();
	return true;
}

void sensor_plugin_loader::show_sensor_info(void)
{
	INFO("========== Loaded sensor information ==========\n");

	int index = 0;

	auto it = m_sensors.begin();

	while (it != m_sensors.end()) {
		sensor_base *sensor = it->second.get();

		sensor_info info;
		sensor->get_sensor_info(info);
		INFO("No:%d [%s]\n", ++index, sensor->get_name());
		info.show();
		it++;
	}

	INFO("===============================================\n");
}

bool sensor_plugin_loader::get_paths_from_dir(const string &dir_path, vector<string> &hal_paths)
{
	DIR *dir = NULL;
	struct dirent *dir_entry = NULL;

	dir = opendir(dir_path.c_str());

	if (!dir) {
		ERR("Failed to open dir: %s", dir_path.c_str());
		return false;
	}

	string name;

	while ((dir_entry = readdir(dir))) {
		name = string(dir_entry->d_name);
		hal_paths.push_back(dir_path + "/" + name);
	}

	closedir(dir);
	return true;
}

sensor_base* sensor_plugin_loader::get_sensor(sensor_type_t type)
{
	auto it_plugins = m_sensors.find(static_cast<sensor_hal_type>(type));

	if (it_plugins == m_sensors.end())
		return NULL;

	return it_plugins->second.get();
}

sensor_base* sensor_plugin_loader::get_sensor(sensor_id_t id)
{
	vector<sensor_base *> sensors;

	sensor_type_t type = static_cast<sensor_type_t> (id & SENSOR_TYPE_MASK);
	unsigned int index = id >> SENSOR_INDEX_SHIFT;

	sensors = get_sensors(type);

	if (sensors.size() <= index)
		return NULL;

	return sensors[index];
}

vector<sensor_base *> sensor_plugin_loader::get_sensors(sensor_type_t type)
{
	vector<sensor_base *> sensor_list;
	std::pair<sensor_plugins::iterator, sensor_plugins::iterator> ret;

	if ((int)(type) == (int)SENSOR_HAL_TYPE_ALL)
		ret = std::make_pair(m_sensors.begin(), m_sensors.end());
	else
		ret = m_sensors.equal_range(static_cast<sensor_hal_type>(type));

	for (auto it = ret.first; it != ret.second; ++it)
		sensor_list.push_back(it->second.get());

	return sensor_list;
}

vector<sensor_base *> sensor_plugin_loader::get_virtual_sensors(void)
{
	vector<sensor_base *> virtual_list;
	sensor_base* sensor;

	for (auto sensor_it = m_sensors.begin(); sensor_it != m_sensors.end(); ++sensor_it) {
		sensor = sensor_it->second.get();

		if (sensor && sensor->is_virtual() == true) {
			virtual_list.push_back(sensor);
		}
	}

	return virtual_list;
}
